title: 操作系统第三讲学习笔记
author: 7h4mid4
tags:
  - 操作系统
categories: []
date: 2019-09-20 13:27:00
---
### 启动

系统刚启动时的内存布局：

地址 | 用途
--- | ---
(4GB - 64KB) ~ 4GB |  	实际BIOS ROM
1MB ~ (4GB - 64KB) | 空闲空间
640KB ~ 1MB | 视频内存，BIOS启动固件（映射）
0 ~ 640KB |  	空闲空间

注意：摘自wiki：

`
这一复杂的映射机制是为了保证向后兼容而设计的。在8086时代，内存只有1MB大小，此时，BIOS的代码固化在EPROM中，且EPROM被编址在1MB内存地址空间的最高64KB中。PC加电后，CS寄存器初始化为0xF000，IP寄存器初始化为0xFFF0，所以CPU要执行的第一条指令的地址为CS:IP=0xF000:0XFFF0（ Segment:Offset表示） =0xFFFF0（ Linear表示） 。这个地址位于被固化的EPROM中，该地址存储了一条指令，它是一个长跳转指令JMP F000:E05B。这样就开启了BIOS的执行过程。
`

CPU在启动之后是处于实模式下的，CS寄存器初始化为0xF000，IP寄存器初始化为0xFFF0，执行的第一条指令存储在0xFFFF0的地址之中，是一个长跳转指令`JMP F000:E05B`，跳转到BIOS程序中，此时系统地址空间只有20位（1MB）

##### 控制权交到BIOS中：

###### 在实模式下提供基本输入输出方法
 - 通过中断调用实现
 - 只能在X86实模式下使用，保护模式不可使用
 
常见中断向量表:
 - INT 10h：字符显示
 - INT 13h:磁盘扇区读写
 - INT 15h：检测内存大小
 - INT 16h：键盘输入

###### BIOS初始化
 - 运行自检程序
 - 更新CMOS中的扩展系统配置数据（ESCD）
 - 按指定启动顺序从盘中启动
 - 加载磁盘首扇区主引导记录MBR
 - 加载活动分区引导扇区
 - 加载分区引导扇区中的启动代码
 
###### 从硬盘加载bootloader到内存
 - 通过启动代码定位bootloader在磁盘中的位置，将bootloader加载到内存0x7c00的位置
 - 跳转到bootloader的位置：CS:IP=0000:7c00,选择启动参数（安全模式、正常启动）等

##### 控制权到bootloader：

###### 切换到保护模式：
###### 将操作系统的代码和数据从硬盘加载到内存中

`注释：
问：为什么不直接从BIOS中读取操作系统的内核映像？
答：磁盘上有文件系统的，文件系统多种多样，BIOS不可能直接识别所有的文件系统，所以利用加载程序（bootloader）来识别文件系统。`

###### 跳转到操作系统的起始地址

此时内存布局：

地址 | 用途
--- | ---
(4GB - 64KB) ~ 4GB |  	实际BIOS ROM
? ~ (4GB - 64KB) | 空闲空间
1MB ~ ? | 操作系统
640KB ~ 1MB | 视频内存，BIOS启动固件（映射）
? ~ 640KB |  	空闲空间
0x7c00 ~ ? | bootloader
0 ~ 0x7c00 |  	BIOS数据


### 中断、异常和系统调用


操作系统用`中断、异常和系统调用`来和外界交互、

先出图：
![upload successful](/images/pasted-10.png)

注意：系统调用总共占用一个中断编号

##### 概念：
 - 中断：外部意外的响应；
 - 异常：指令执行意外的响应；
 - 系统调用：系统调用指令的响应。

软中断和硬中断的区别。

#### 异同点：

##### 相同点：
都会进入异常服务例程，切换为内核态。

##### 不同点：
- 源头不同，中断源是外部设备，异常和系统调用源是应用程序；
- 响应方式不同，中断是异步的，异常是同步的，系统调用异步和同步都可以。
- 处理机制不同，中断对用户程序是透明的，异常会重新执行用户指令或杀死用户进程，系统调用一般是用户程序调用的

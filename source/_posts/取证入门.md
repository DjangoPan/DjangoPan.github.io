title: 内存取证入门
author: 7h4mid4
tags:
  - 取证
  - 内存
  - volatility
categories: []
date: 2019-09-06 22:55:00
---
### Volatility的基本介绍

Volatility是一款基于GNU协议的开源框架，使用Python语言编写而成的内存取证工具集，可以分析内存中的各种数据。Volatility支持对32位或64位Wnidows、Linux、Mac、Android操作系统的RAM（随机存储器）数据进行提取与分析。

### 内存镜像的获取

`MoonSols DumpIt`是一款同时支持Win32dd和Win64dd的内存副本获取工具。用户只需双击DumpIt.exe可执行程序，并在提示问题后面输入y（如图2.2所示），等待几分钟时间即可在当前目录下生成主机物理内存的副本（如图2.3所示），该副本文件是以*.raw为后缀的镜像文件。

raw是未经处理的意思，即使用该工具对物理内存进行拷贝是按每一个bit进行深度复制，即按原样进行复制，这样可以避免丢失一些重要数据。


拿到一个镜像文件，在cmd进入所在目录，输入:
        
        .\volatility  -f <memdump.img> imageinfo
        
##### Suggested profiles：策略，会告诉你这个内存镜像可以使用什么策略，策略通过`imageinfo`命令获取。


使用策略方法：

        .\volatility  -f <memdump.img> --profile=Win7SP1x64


#### 查看镜像信息：

        -f <memdump.img> imageinfo
        
##### 显示主机所使用的操作系统版本、服务包以及硬件结构(32位或64位)、页目录表的起始地址和该获取该内存镜像的时间等基本信息


        
#### 查找内存中KPCR的_KPCR结构体信息：

        -f <memdump.img>  --profile=<prifile> kprcscan                        需要好几个小时。

在_KPCR的帮助下我们可以枚举机器上运行的进程列表。


由于Windows需要支持多个CPU，因此Windows内核中为此定义了一套以处理器控制区(Processor Control Region)即KPCR为枢纽的数据结构，使每个CPU都有个KPCR。 其中KPCR这个结构中有一个域KPRCB(Kernel Processor Control Block)结构，这个结构扩展了KPCR，这两个结构用来保存**与线程切换相关的全局信息。**


具体的说，该命令可以显示每个处理器的详细信息，**包括IDT（线程控制符）和GDT（全局段描述符表）地址，当前运行的线程和空闲线程，CPU数量、制造厂商及其速度，CR3寄存器或页目录表基地址的值等信息。**


        -f <memdump.img>  --profile=<prifile> kpcrscan


#### 查看进程：

        -f <memdump.img>  --profile=<prifile> pslist
        -f <memdump.img>  --profile=<prifile> pstree
        以树的形式显示出来
        -f <memdump.img>  --profile=<prifile> psscan
        -f <memdump.img>  --profile=<prifile> psxview

##### pslist可以枚举系统中的进程，这条命令通过遍历PsActiveProcessHead指针指向的双向链表枚举当前内存中活跃的所有进程信息，主要包括偏移地址、进程ID号、父进程ID号、线程数量、句柄数量、进程会话ID号以及进程开始和退出的时间。


##### psscan命令能够通过内存池标签查找的方式枚举系统中的所有进程，这条命令不仅能够显示当前内存中活跃的进程信息，还能够枚举以前终止的进程和被隐藏以及被rootkit破坏的未在活跃进程链表中出现的进程。

        -f <memdump.img>  --profile=<prifile> psscan

##### 显示的时间都是世界统一时间UTC，而中国在东八区，需要转换。




#### 查看用户SID： 

        -f <memdump.img>  --profile=<prifile> getsids
        
        
#### 查看系统中的用户：

        -f <memdump.img>  --profile=<prifile> printkey -K "SAM\Domains\Account\Users\Names"
        
        

#### 获取系统中最后登录用户


        -f <memdump.img>  --profile=<prifile> printkey -K "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon


#### 查看启动项：

         
         -f <memdump.img>  --profile=<prifile> printkey -K "Microsoft\Windows\CurrentVersion\Run"
        

#### 查看动态链接库的信息：

        -f <memdump.img>  --profile=<prifile> dlllist [-p pid]



##### 显示列表包括：动态链接库文件的基地址、文件大小以及文件所在路径。


#### 查看临时内存注册表信息：

        -f <memdump.img>  --profile=<prifile> hivelist
        -f <memdump.img>  --profile=<prifile> lsadump -y SYSTEM的virtualaddr -s SECURITY的virtualaddr

        都是用来查看第二类注册表信息
        
        
##### 注册表不是一个简单的大文件，而是一个集合，由称为“注册表文件(hive)”的分散文件组成。


##### 注册表文件主要包括两类：
##### 第一类：存储在磁盘上的静态数据，这类注册表文件一般被保存在操作系统的system32\config文件夹下。一般在运行中使用regedit查看。
##### 第二类;易失性注册表数据，这类注册表文件是由Windows内核负责维护的RAM中的数据，它们在系统每次启动的时候才会被创建。

#### hivelist：
##### 定位与硬盘上对应的注册表文件在内存中的**虚拟地址**和**物理地址**。特别是当你想打印某个注册表文件的值时，就需要先运行这个命令。

#### lsadump：

##### 使用lsadump命令可以读取注册表中的与本地安全授权相关的秘密数据。

##### LSA(Local Security Authority)即本地安全授权。Windows系统中一个相当重要的服务，所有安全认证相关的处理都要通过这个服务。比如系统自动登录的缺省密码、远程桌面协议的公钥、Windows数据保护应用程序编程接口使用的授权证书等信息。

##### 使用该命令的时候，需要把上文提到的SYSTEM注册表的虚拟地址作为-y选项的参数和SECURITY注册表文件的地址作为-s选项的参数.

        -f <memdump.img> --profile=<prifile> lsadump -y SYSTEM的virtualaddr -s SECURE的virtualaddr


#### 获取注册表信息以爆破密码：
        -f <memdump.img>  --profile=<prifile> hashdump -y SYSTEM的virtualaddr -s SAM的virtualaddr


##### 之后就能看到用户名和两个hash值，选后面那个hash值，用www.cmd5.com 搜索hash转文字，用NTLM来查SAM中的hash。



#### 查看历史命令：

        -f <memdump.img>  --profile=<prifile> cmdscan
        
#### 查看控制台命令：

        -f <memdump.img>  --profile=<prifile> consoles

#### 查看网络连接（TCP连接）：

        -f <memdump.img>  --profile=<prifile> connections           Vista前的系统用的
        -f <memdump.img>  --profile=<prifile> netscan                 Vista后的系统用的

#### 查看IE历史：

        -f <memdump.img>  --profile=<prifile> iehistory

#### 获取用户密码散列:

        -f <memdump.img>  --profile=<prifile> hashdump(-y systemadd –s samadd)

#### 获取内存中活跃的TCP连接

        -f <memdump.img>  --profile=<prifile> connections


#### 查看系统中已打开的文件（rootkit隐藏文件）

        -f <memdump.img>  --profile=<prifile> filescan
        
#### 导出相关filescan的文件
        
        -f file_patched.dmp --profile=Win7SP1x86_23418 dumpfiles -D ./ -Q 0x000000000e080690
        
 #### 显示在一个进程中打开的句柄
 
        -f <memdump.img>  --profile=<prifile> handles -p <pid> -t <file>
        
#### 显示内核中的驱动程序，包括已隐藏/链接的

        -f <memdump.img>  --profile=<prifile> modules
        查看内核驱动（不全）
        -f <memdump.img>  --profile=<prifile> modscan
        -f <memdump.img>  --profile=<prifile> driverscan
        
        
#### 查看服务

        -f <memdump.img>  --profile=<prifile> svcscan
        
#### 查看各组件时间线

        -f <memdump.img>  --profile=<prifile> timeliner
        输出一般很多，建议输出到制定文件中
        
        
#### 查看系统或桌面执行文件的信息。

        -f <memdump.img>  --profile=<prifile> userassist
        
       包括  ：名称、路径、执行次数、最后一次执行时间等
       
       
#### 将内存中的某个进程数据以 dmp 的格式保存出来
 
 
        -f <memdump.img>  --profile=<prifile> memdump -p [PID] -D [dump 出的文件保存的目录]
        举例：
        volatility -f mem.vmem --profile=WinXPSP2x86 memdump -p 1734 -D ctf/
        
        
        hexdump 1734.dmp
        二进制编辑器 hexeditor 将以上保存的 dmp 文件打开，并进行调查取证的工作。
        
        
        你还可以使用 strings 这个工具将它的字符串打印出来。例：
        
        strings 1736.dmp > 1736.txt
        strings 1608.dmp > 1736.txt | grep shellcode
        
        
 
--cache选项的功能是使用缓存。
--dtb=DTB选项的功能是说明DTB(Directory Table Base)页目录表的基地址。
-k KPCR 选项的功能是说明一个指定的内核处理器控制区的虚拟地址。
Apihooks插件命令的功能是监测在进程和内核中的API钩子。
Bioskbd插件命令的功能是动态地从内存中读取键盘缓冲区的数据。





[命令行指南](https://github.com/volatilityfoundation/volatility/wiki/Command-Reference)

附上一篇好文章，其中有一些典型的题目可以参考，日后感兴趣的可以做做。
[传送门](http://shaobaobaoer.cn/archives/693/memory-forensics-tool-volatility-usage-and-practice)

另外加上一篇[USB流量分析文章](https://www.cnblogs.com/ECJTUACM-873284962/p/9473808.html)